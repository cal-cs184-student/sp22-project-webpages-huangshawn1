<html>
	<style>
	@media print {
	    .pagebreak { page-break-before: always; } /* page-break-after works, as well */
	}
	#images{
    	text-align:center;
    	margin:50px auto; 
	}
	#images a{
	    margin:0px 20px;
	    display:inline-block;
	    text-decoration:none;
	    color:black;
	}
	</style>
	<head>
	</head>
	<body>
		Part 1<br>
		Casteljau's algorithm involves linearly interpolating between the points to get intermediate points repeatedly until we get one point on the Bezier curve. We then repeat with t from 0 to 1 to get the full curve. In my implementation I simply interpolate between consecutive points to get n-1 points and return the resulting array.<br>
		in order: step 1, step 2, step 3, step 4, step 5, slightly different curve<br><br>
		<img src='part_1_step_1.png' height='200'><img src='part_1_step_2.png' height='200'><br>
		<img src='part_1_step_3.png' height='200'><img src='part_1_step_4.png' height='200'><br>
		<img src='part_1_step_5.png' height='200'><img src='part_1_different.png' height='200'><br><br>
		<div class="pagebreak"> </div>

		Part 2<br>
		The surface algorithm is very similar to the version for curves. We essentially generate a set of intermediate points (one along each row of our grid of control points) by using the same process as the curve algorithm. We can then apply the curve algorithm to this column of intermediate points to get our final point. The rows are parameterized by u and columns by v instead of the single parameter t from the curve algorithm.<br>
		My implementation for evaluateStep was the same as for the curve (interpolate consecutive points). evaluate1D was just repeating evaluateStep until there was a single point. The evaluate function first generates the intermediate points for each row using evaluate1D, then calls evaluate1D one final time on this column of points.<br><br>
		<img src='part_2.png' height='400'><br><br>
		<div class="pagebreak"> </div>
	</body>
</html>